### ‚úçÔ∏èFleeting Notes

- [[üöÄProject - rollup]]
- [[üöÄProject - one]]
- [[üöÄProject - adsad]]
- [[üöÄProject - asdasfga]]
- [[üöÄProject - afafgasf]]
___
### üìåMy tasks for today
~~~dataviewjs
(async () => {
  const host = dv.current().file.name;
  const m = window.moment(host, ["D MMM YYYY", "DD MMM YYYY", "YYYY-MM-DD"], true);
  if (!m.isValid()) { dv.paragraph("Filename needs a date like 11 Oct 2025 or 2025-10-11."); return; }
  const ISO = m.format("YYYY-MM-DD");

  const pages = dv.pages().where(p =>
    !/Templates|Archive/i.test(p.file.folder) &&
    !/[!]\s*$/.test(p.file.name) &&
    p.file.name.includes("Task")
  );

  const prRank = { High: 1, Medium: 2, Med: 2, Low: 3 };
  const rx = s => String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const toNum = v => Number.isFinite(Number(v)) ? Number(v) : 0;
  function sectionText(src, name) {
    const re = new RegExp(`^#{1,6}\\s+${rx(name)}\\s*$`, "gim");
    const m = re.exec(src); if (!m) return null;
    const start = m.index + m[0].length;
    const level = (m[0].match(/^#+/) || ["#"])[0].length;
    const next = new RegExp(`^#{1,${level}}\\s+`, "gim"); next.lastIndex = start;
    const n = next.exec(src);
    return { text: src.slice(start, n ? n.index : src.length) };
  }
  function firstCheckbox(sec) {
    const re = /^[ \t>]*[-*]\s+\[( |x|X)\]\s.*$/m;
    const m = re.exec(sec.text); if (!m) return null;
    return { checked: /\[(x|X)\]/.test(m[0]) };
  }

  const rows = [];
  for (const p of pages) {
    let dueISO = null;
    if (p.due) {
      const mdue = window.moment(String(p.due), ["YYYY-MM-DD", "D MMM YYYY", window.moment.ISO_8601], true);
      if (mdue.isValid()) dueISO = mdue.format("YYYY-MM-DD");
    }
    if (dueISO !== ISO) continue;

    const file = app.vault.getAbstractFileByPath(p.file.path);
    if (!file) continue;
    const text = await app.vault.read(file);
    const sec = sectionText(text, "My Task");
    if (!sec) continue;
    const box = firstCheckbox(sec);
    if (!box) continue;

    const checked = typeof p.done === "boolean" ? p.done : box.checked;
    rows.push({
      path: p.file.path,
      name: p.file.name,
      checked,
      pri: p.priority ?? "",
      dur: toNum(p.duration_hours ?? 0),
      timeslot: (p.timeslot ?? "Anytime").trim()
    });
  }

  if (!rows.length) { dv.paragraph("Can't find any. This must be Sunday üòÉü™Å"); return; }

  const slotOrder = ["Morning", "Afternoon", "Evening", "Anytime"];
  const slotEmoji = { Morning: "üåÖ", Afternoon: "üåû", Evening: "üåô", Anytime: "üïí" };
  const slotDesc  = {
    Morning: "High impact work",
    Afternoon: "Admin work",
    Evening: "Review and tomorrow planning",
    Anytime: "Flexible tasks"
  };
  const groups = Object.fromEntries(slotOrder.map(s => [s, []]));
  for (const r of rows) groups[slotOrder.includes(r.timeslot) ? r.timeslot : "Anytime"].push(r);

  const wrap = document.createElement("div");
  wrap.style.display = "block";

  for (const slot of slotOrder) {
    const group = groups[slot];
    const hasItems = group.length > 0;

    const g = document.createElement("div");
    g.style.marginBottom = "16px";

    const header = document.createElement("div");
    header.style.fontWeight = "600";
    header.style.margin = "0";
    if (hasItems) {
      const count = group.length;
      const hours = group.reduce((a, b) => a + (b.dur || 0), 0);
      header.textContent =
        `${slotEmoji[slot]} ${slot} (${count} task${count > 1 ? "s" : ""} ‚Ä¢ ${hours} hr${hours === 1 ? "" : "s"})`;
    } else {
      header.textContent = `${slotEmoji[slot]} ${slot} (None)`;
    }
    g.appendChild(header);

    const subtitle = document.createElement("div");
    subtitle.style.opacity = "0.8";
    subtitle.style.fontStyle = "italic";
    subtitle.style.marginTop = "2px";
    subtitle.style.marginBottom = hasItems ? "4px" : "0";
    subtitle.textContent = slotDesc[slot] || "";
    g.appendChild(subtitle);

    if (hasItems) {
      group.sort((a, b) => {
        const ap = prRank[a.pri] ?? 9, bp = prRank[b.pri] ?? 9;
        return ap - bp || (a.dur ?? 0) - (b.dur ?? 0);
      });

      const listDiv = document.createElement("div");
      for (const r of group) {
        const row = document.createElement("div");
        row.style.display = "grid";
        row.style.gridTemplateColumns = "auto 1fr";
        row.style.alignItems = "start";
        row.style.columnGap = "8px";
        row.style.rowGap = "0";
        row.style.padding = "2px 0";
        row.style.minWidth = "0";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = r.checked;
        cb.style.margin = "0";

        const content = document.createElement("div");
        content.style.minWidth = "0";
        content.style.lineHeight = "1.35";

        const link = document.createElement("a");
        link.textContent = r.name;
        link.href = "#";
        link.style.minWidth = "0";
        link.onclick = e => { e.preventDefault(); app.workspace.openLinkText(r.path, dv.current().file.path, false); };

        const meta = document.createElement("span");
        meta.style.opacity = "0.8";
        meta.style.marginLeft = "8px";
        const bits = [r.pri || "", `${r.dur} hr${r.dur === 1 ? "" : "s"}`].filter(Boolean);
        meta.textContent = bits.length ? "¬∑ " + bits.join(" ¬∑ ") : "";

        const doneMark = document.createElement("span");
        doneMark.textContent = " ‚úÖ";
        doneMark.style.marginLeft = "6px";
        doneMark.style.display = r.checked ? "inline" : "none";

        content.append(link, meta, doneMark);
        row.append(cb, content);
        listDiv.appendChild(row);

        const applyDoneStyle = done => {
          link.style.textDecoration = done ? "line-through" : "none";
          meta.style.display = done ? "none" : "inline";
          doneMark.style.display = done ? "inline" : "none";
        };
        applyDoneStyle(r.checked);

        cb.addEventListener("change", async () => {
          const f = app.vault.getAbstractFileByPath(r.path);
          if (!f) return;
          await app.fileManager.processFrontMatter(f, fm => { fm.done = cb.checked; });
          applyDoneStyle(cb.checked);
          checkAllDone();
        });
      }
      g.appendChild(listDiv);
    }
    wrap.appendChild(g);
  }

  const msg = document.createElement("div");
  msg.style.marginTop = "6px";
  msg.style.textAlign = "left";
  msg.style.fontWeight = "500";

  const checkAllDone = () => {
    const boxes = wrap.querySelectorAll('input[type="checkbox"]');
    if (!boxes.length) { msg.textContent = ""; return; }
    msg.textContent = Array.from(boxes).every(x => x.checked) ? "All done, nice work! üéâ‚òïÔ∏è" : "";
  };
  checkAllDone();

  dv.container.append(wrap, msg);
})();
~~~
___
### üîÅMy habits for today:
```dataviewjs
const HABIT_FOLDER = "03 SaveBox/Active";

// Get date from current note's filename: DD MMM YYYY
const fileName = dv.current()?.file?.name ?? "";
const m = fileName.match(/(\d{1,2} [A-Za-z]{3} \d{4})/);

let fileDate = null;
if (m) fileDate = window.moment(m[1], "DD MMM YYYY").format("YYYY-MM-DD");

if (!fileDate) {
  dv.paragraph("No valid date found in filename.");
} else {
  const pages = dv.pages(`"${HABIT_FOLDER}"`)
    .where(p => p.file.name.includes("Habit -") || p.file.name.includes("üîÅHabit -"));

  function pickTasksForDate(p) {
    const ts = p.file.tasks ?? [];
    const rx = new RegExp(`(?:\\s|\\^)${fileDate}\\s*$`);
    const dated = ts.filter(t => rx.test(t.text));
    if (!dated.length) return null;
    return dated.find(t => !t.completed) ?? dated[0];
  }

  const tasks = pages.array().map(pickTasksForDate).filter(Boolean);
  if (tasks.length) dv.taskList(tasks, false);
  else dv.paragraph(`No habit tasks for ${m[1]}.`);
}

```
### ‚è∞My overdue tasks
~~~dataviewjs
(async () => {
  // --- host date from filename: "11 Oct 2025" or "2025-10-11"
  const host = dv.current().file.name;
  const m = window.moment(host, ["D MMM YYYY", "DD MMM YYYY", "YYYY-MM-DD"], true);
  if (!m.isValid()) { 
    dv.paragraph("Filename needs a date like 11 Oct 2025 or 2025-10-11."); 
    return; 
  }
  const TODAY = m.startOf("day");

  // --- candidates: Task notes only, exclude Templates/Archive and names ending with "!"
  const pages = dv.pages().where(p =>
    !/Templates|Archive/i.test(p.file.folder) &&
    !/[!]\s*$/.test(p.file.name) &&
    p.file.name.includes("Task")
  );

  // --- helpers
  const prRank = { High: 1, Medium: 2, Med: 2, Low: 3 };
  const rx = s => String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const toNum = v => Number.isFinite(Number(v)) ? Number(v) : 0;

  function sectionText(src, name) {
    const re = new RegExp(`^#{1,6}\\s+${rx(name)}\\s*$`, "gim");
    const m = re.exec(src); 
    if (!m) return null;
    const start = m.index + m[0].length;
    const level = (m[0].match(/^#+/) || ["#"])[0].length;
    const next = new RegExp(`^#{1,${level}}\\s+`, "gim"); 
    next.lastIndex = start;
    const n = next.exec(src);
    return { text: src.slice(start, n ? n.index : src.length) };
  }

  function firstCheckbox(sec) {
    const re = /^[ \t>]*[-*]\s+\[( |x|X)\]\s.*$/m;
    const m = re.exec(sec.text); 
    if (!m) return null;
    return { checked: /\[(x|X)\]/.test(m[0]) };
  }

  // --- gather OVERDUE tasks (due date < TODAY and not done)
  const rows = [];
  for (const p of pages) {
    // parse due from YAML
    let due = null;
    if (p.due) {
      const mdue = window.moment(String(p.due), ["YYYY-MM-DD", "D MMM YYYY", window.moment.ISO_8601], true);
      if (mdue.isValid()) due = mdue.startOf("day");
    }
    if (!due) continue;

    const daysDue = TODAY.diff(due, "days");
    if (daysDue <= 0) continue; // today or future are excluded

    // read the first checkbox under "My Task"
    const file = app.vault.getAbstractFileByPath(p.file.path);
    if (!file) continue;
    const text = await app.vault.read(file);
    const sec = sectionText(text, "My Task");
    if (!sec) continue;
    const box = firstCheckbox(sec);
    if (!box) continue;

    const checked = typeof p.done === "boolean" ? p.done : box.checked;
    if (checked) continue; // ‚úÖ skip completed tasks

    rows.push({
      path: p.file.path,
      name: p.file.name,
      checked,
      pri: p.priority ?? "",
      dur: toNum(p.duration_hours ?? 0),
      daysDue,
    });
  }

  if (!rows.length) { 
    dv.paragraph("No overdue tasks üéâ"); 
    return; 
  }

  // --- sort: most overdue first, then priority, then shorter duration
  rows.sort((a, b) => {
    const ap = prRank[a.pri] ?? 9, bp = prRank[b.pri] ?? 9;
    return b.daysDue - a.daysDue || ap - bp || (a.dur ?? 0) - (b.dur ?? 0);
  });

  // --- render: single flat list, checkbox + title + meta inline
  const listDiv = document.createElement("div");

  for (const r of rows) {
    const row = document.createElement("div");
    row.style.display = "grid";
    row.style.gridTemplateColumns = "auto 1fr";
    row.style.alignItems = "start";
    row.style.columnGap = "8px";
    row.style.rowGap = "0";
    row.style.padding = "2px 0";
    row.style.minWidth = "0";

    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = r.checked;
    cb.style.margin = "0";

    const content = document.createElement("div");
    content.style.minWidth = "0";
    content.style.lineHeight = "1.35";

    const link = document.createElement("a");
    link.textContent = r.name;
    link.href = "#";
    link.style.minWidth = "0";
    link.onclick = e => { 
      e.preventDefault(); 
      app.workspace.openLinkText(r.path, dv.current().file.path, false); 
    };

    // meta: "X days due ¬∑ Priority ¬∑ Duration"
    const meta = document.createElement("span");
    meta.style.opacity = "0.8";
    meta.style.marginLeft = "8px";
    const dueText = `${r.daysDue} day${r.daysDue === 1 ? "" : "s"} due`;
    const time = `${r.dur} hr${r.dur === 1 ? "" : "s"}`;
    const bits = [dueText, r.pri || "", time].filter(Boolean);
    meta.textContent = bits.length ? "¬∑ " + bits.join(" ¬∑ ") : "";

    const doneMark = document.createElement("span");
    doneMark.textContent = " ‚úÖ";
    doneMark.style.marginLeft = "6px";
    doneMark.style.display = r.checked ? "inline" : "none";

    content.append(link, meta, doneMark);
    row.append(cb, content);
    listDiv.appendChild(row);

    const applyDoneStyle = done => {
      link.style.textDecoration = done ? "line-through" : "none";
      meta.style.display = done ? "none" : "inline";
      doneMark.style.display = done ? "inline" : "none";
    };
    applyDoneStyle(r.checked);

    // sync YAML `done` in the task note
    cb.addEventListener("change", async () => {
      const f = app.vault.getAbstractFileByPath(r.path);
      if (!f) return;
      await app.fileManager.processFrontMatter(f, fm => { fm.done = cb.checked; });
      applyDoneStyle(cb.checked);
      checkAllDone();
    });
  }

  // --- footer message when all overdue are checked
  const msg = document.createElement("div");
  msg.style.marginTop = "6px";
  msg.style.textAlign = "left";
  msg.style.fontWeight = "500";

  const checkAllDone = () => {
    const boxes = listDiv.querySelectorAll('input[type="checkbox"]');
    if (!boxes.length) { 
      msg.textContent = ""; 
      return; 
    }
    msg.textContent = Array.from(boxes).every(x => x.checked)
      ? "All done, nice work! üéâ‚òïÔ∏è"
      : "";
  };
  checkAllDone();

  dv.container.append(listDiv, msg);
})();
~~~
___
#### üîÑ End-of-Day Review
How did the day go?
What worked and what didn‚Äôt?
What will you do differently tomorrow?
- 
- 
---
### üì´Inbox:
*Remove suffix "!" to release*
~~~dataviewjs
// üìÇ Inbox (no date, tight spacing)
// Excludes Archive + Templates + Notes
// Only includes filenames ending with "!"

const M = window.moment;

// --- filters ---
const pages = dv.pages().where(p =>
  p.file &&
  !/Archive|Templates/i.test(p.file.folder || "") &&
  !/note/i.test(p.file.name || "") &&
  /!\s*$/.test(p.file.name || "")
);

// --- sort oldest ‚Üí newest ---
const list = pages.array().sort((a,b) => (a.file.ctime ?? 0) - (b.file.ctime ?? 0));

if (!list.length) {
  dv.el("p", "Inbox empty.");
} else {
  const today = M();

  const lines = list.map(p => {
    const created = M(p.file.ctime);
    const days = today.diff(created, "days");
    const ageLabel = days === 0 ? "today" : `${days} day${days === 1 ? "" : "s"} ago`;
    return `- ${p.file.link} ‚Ä¢ ${ageLabel}`;
  });

  const wrap = dv.el("div", lines.join("\n"), { cls: "inbox-list" });

  const style = document.createElement("style");
  style.textContent = `
    .inbox-list {
      margin-top: 0 !important;
      padding-top: 0 !important;
      line-height: 1.5;
    }
    .inbox-list p, .inbox-list ul, .inbox-list div {
      margin-top: 0 !important;
      padding-top: 0 !important;
    }
  `;
  wrap.appendChild(style);
}
~~~
___
### üîóLinks:
-
~~~dataviewjs
// üìÖ Daily + Mind Map on top, then linked/backlink notes (A‚ÄìZ)
// For Task/Project/Goal: show Done / Not Done instead of date

const M = window.moment;
const todayStr = M().format("DD MMM YYYY");
const cur = dv.current().file ?? {};
const curPath = cur.path ?? "";

// --- Top lines ---
const todays = dv.pages().where(p =>
  p.file &&
  !/Archive|Templates/i.test(p.file.folder || "") &&
  (p.file.name || "").includes(todayStr)
);
const daily = todays.length ? todays[0].file.link : "None";
dv.el("div", `üìÖ ${daily} ‚Ä¢ Today's daily note`, { cls: "note-line" });
dv.el("div", `[[üß†Mind Map]] ‚Ä¢ Bird's-eye view`, { cls: "note-line" });

// --- Helpers ---
const normalizeLinks = links =>
  (links ?? []).map(l => typeof l === "string" ? l : l?.path).filter(Boolean);

const createdOf = p => {
  if (p?.created) {
    const m = M(p.created, ["DD MMM YYYY", "YYYY-MM-DD"], true);
    if (m.isValid()) return m;
  }
  return M(p?.file?.ctime);
};

const isTPG = name => /(Task|Project|Goal)/i.test(name || "");
const isDone = p => {
  if (typeof p?.done === "boolean") return p.done;
  const tasks = p?.file?.tasks ?? [];
  return tasks.length ? tasks.every(t => t.completed) : false;
};

// --- Collect linked + backlinks ---
const curOut = new Set(normalizeLinks(cur.outlinks));

const base = dv.pages().where(p => {
  const f = p?.file;
  if (!f) return false;
  const folder = f.folder ?? "";
  const name = f.name ?? "";
  if (/Archive|Templates/i.test(folder)) return false;
  if (!/(note|task|project|goal)/i.test(name)) return false;
  if (name.includes("!")) return false;
  if (f.path === curPath) return false;
  return true;
});

// outlinks to or from current
const linked = base
  .where(p => {
    const path = p.file.path;
    const pOut = normalizeLinks(p.file.outlinks);
    return pOut.includes(curPath) || curOut.has(path);
  })
  .array();

// backlinks from anywhere
const backlinks = dv.pages()
  .where(p =>
    p.file?.outlinks?.some(l => l.path === curPath) &&
    !/Archive|Templates/i.test(p.file.folder || "")
  )
  .array();

// unique, sort A‚ÄìZ by name
const unique = Array.from(new Map([...linked, ...backlinks].map(p => [p.file.path, p])).values())
  .sort((a, b) => (a.file.name || "").localeCompare(b.file.name || "", undefined, { sensitivity: "base" }));

// --- Render if any ---
if (unique.length) {
  const items = unique.map(p => {
    const name = p.file.name || "";
    if (isTPG(name)) {
      return `${p.file.link} ‚Ä¢ ${isDone(p) ? "Done" : "Not Done"}`;
    } else {
      return `${p.file.link} ‚Ä¢ ${createdOf(p).format("DD MMM YYYY")}`;
    }
  });
  dv.el("div", items.join("<br>"), { cls: "note-list" });
}

// --- Styles (balanced) ---
const style = document.createElement("style");
style.textContent = `
.note-line { margin: 3px 0 !important; padding: 0 !important; line-height: 1.4; }
.note-list { margin-top: 6px !important; padding: 0 !important; line-height: 1.4; }
.note-list br { line-height: 1.4; }
`;
dv.container.append(style);
~~~
___
<p align="center">Template created by Akhmad Fauzan. <br>All rights reserved</p>
## Habits Today

```mindmapos-habits-today
folder: 03 SaveBox/Active
```

___
<p align="center">Template created by Akhmad Fauzan<br>¬©Ô∏èAll rights reserved</p>
